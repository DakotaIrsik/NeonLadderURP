+-- Animation
  +-- AvatarMasks
    |   UpperBodyMask.mask
  +-- Controllers
    +-- Enemies
      +-- Boss
        |   Anglerox.controller
        |   Arack.controller
        |   Ceratoferox.controller
        |   Gobbler.controller
        |   Hara.controller
        |   Onyscidus.controller
        |   Rapax.controller
        |   Sins.controller
        |   Ursacetus.controller
      +-- Major
        |   Crab.controller
        |   CrabSpider.controller
        |   DragonShark.controller
        |   FlyingFrog.controller
        |   Gorilla.controller
        |   Lizard.controller
        |   Scorpion.controller
        |   Turtle.controller
      +-- Minor
        |   BattleBee.controller
        |   BishopKnight.controller
        |   BlackKnight.controller
        |   DemonKnight.controller
        |   Fishman.controller
        |   Golem.controller
        |   LizardKnight.controller
        |   Mimic.controller
        |   NagaWizard.controller
        |   OneArmedCrab.controller
        |   Rat.controller
        |   Salamander.controller
        |   Skeleton.controller
        |   Spider.controller
        |   Stingray.controller
        |   Werewolf.controller
    +-- Protagonist
      |   Kairi.controller
+-- Audio
  +-- Background
    +-- Boss
      |   boss-1-intro.mp3
      |   boss-1-loop.mp3
    +-- Interior
      |   Background-Track-1.mp3
      |   Background-Track-2.mp3
    +-- Overworld
      |   Background-Track-1.mp3
      |   Background-Track-2.mp3
    |   DownloadInstructions.txt
  +-- Collectibles
    |   Collectible.wav
  +-- Enemies
    +-- Boss
      +-- Wrath
        |   Death.wav
        |   Hurt.wav
        |   jump.wav
        |   LandOnEnemy.wav
        |   LandOnGround.wav
        |   Walk01.wav
        |   Walk02.wav
    +-- Major
      +-- Karcinomorph
        |   Death.wav
        |   Hurt.wav
        |   jump.wav
        |   LandOnEnemy.wav
        |   LandOnGround.wav
        |   Walk01.wav
        |   Walk02.wav
    +-- Minor
      +-- Salamander
        |   Death.wav
        |   Hurt.wav
        |   jump.wav
        |   LandOnEnemy.wav
        |   LandOnGround.wav
        |   Walk01.wav
        |   Walk02.wav
  +-- Player
    |   Death.wav
    |   Hurt.wav
    |   jump.wav
    |   LandOnEnemy.wav
    |   LandOnGround.wav
    |   Walk01.wav
    |   Walk02.wav
  |   AudioTrigger.cs
+-- Controls
  |   InputSystem.inputsettings.asset
+-- Icons
  |   Game-Spash-Screen.png
  |   NeonLadder.png
  |   Studio-Splash-Screen.png
+-- Images
  |   Meta-Currency-Icon.png
  |   Perma-Currency-Icon.png
+-- Logging
  |   AppLogger.cs
+-- Materials
  |   T_Screen_BG_SIGN_TEXT_ALPHA.TGA
+-- Piloto Studio
  +-- Shaders
    +-- PBR_Piloto
      |   m_pbr_gradient_test.mat
    +-- VFX_Piloto
      |   Opaque UberFX.shader
+-- Polybrush Data
  +-- Brush Settings
    |   BrushSettings-Default.asset
  +-- Color Palette
    |   ColorPalette-Default.asset
  +-- Prefab Palette
    |   PrefabPalette-Default.asset
  +-- Samples
    +-- Polybrush
      +-- 1.0.2
        +-- Shader Examples (HDRP)
          +-- Shader
            |   Lit Texture Blend HDRP.ShaderGraph
            |   Lit Vertex Color HDRP.ShaderGraph
+-- Prefabs
  +-- Actors
    +-- Enemies
      +-- Boss
        +-- Transformations
          |   Anglerox.prefab
          |   Arack.prefab
          |   Ceratoferox.prefab
          |   Gobbler.prefab
          |   Onyscidus.prefab
          |   Rapax.prefab
          |   Ursacetus.prefab
        |   EnemyScripts.prefab
        |   Envy.prefab
        |   Gluttony.prefab
        |   Greed.prefab
        |   Hara.prefab
        |   Lust.prefab
        |   Pride.prefab
        |   Sloth.prefab
        |   Wrath.prefab
      +-- Major
        |   Crab.prefab
        |   CrabSpider.prefab
        |   DragonShark.prefab
        |   EnemyScripts.prefab
        |   FlyingFrog.prefab
        |   Gorilla.prefab
        |   Lizard.prefab
        |   Scorpion.prefab
        |   Turtle.prefab
      +-- Minor
        |   BattleBee.prefab
        |   BishopKnight.prefab
        |   BlackKnight.prefab
        |   DemonKnight.prefab
        |   EnemyScripts.prefab
        |   Fishman.prefab
        |   Golem.prefab
        |   LizardKnight.prefab
        |   Mimic.prefab
        |   NagaWizard.prefab
        |   OneArmedCrab.prefab
        |   Rat.prefab
        |   Salamander.prefab
        |   Skeleton.prefab
        |   Spider.prefab
        |   Stingray.prefab
        |   Werewolf.prefab
      |   AllMonsterGroups.prefab
      |   Group1.prefab
      |   Group2.prefab
      |   Group3.prefab
      |   Group4.prefab
      |   Group5.prefab
      |   Group6.prefab
      |   Group7.prefab
      |   Group8.prefab
    +-- NPCs
      |   Aria.prefab
      |   Ellie.prefab
    +-- Players
      |   Kaoru.prefab
      |   PlayerScripts.prefab
    |   F3_Green Variant.prefab
    |   SpawnPoint.prefab
  +-- Buildings
  +-- Cameras
    |   Main Camera.prefab
    |   PlayerCamera.prefab
  +-- Collectibles
    |   HealthReplenishment.prefab
    |   MetaCurrency.prefab
    |   PermaCurrency.prefab
  +-- Events
    |   EventSystem.prefab
  +-- Gameplay
    |   GameController.prefab
  +-- Lighting
    |   Directional Light.prefab
    |   Global Volume.prefab
  +-- Managers
    |   DialogueManager.prefab
    |   EnemyDefeatedManager.prefab
    |   EventManager.prefab
    |   GameControllerManager.prefab
    |   HealthIncreaseStatManager.prefab
    |   LootDropManager.prefab
    |   LootPurchaseManager.prefab
    |   Managers.prefab
    |   MonsterGroupActivationManager.prefab
    |   PlayerCameraPositionManager.prefab
    |   PlayerHealthUIManager.prefab
    |   PlayerStaminaUIManager.prefab
    |   SceneChangeManager.prefab
    |   SteamManager.prefab
  +-- PlaceHolder
    |   TransitionPlaceholder.prefab
  +-- Portals
    |   EnemySpawn.prefab
  +-- ProceduralGeneration
    |   SceneChange.prefab
    |   SceneChangeCanvas.prefab
    |   SceneExitAssignmentManager.prefab
  +-- Ranged
    |   Holy.prefab
  +-- Scenes
    |   AllowZMovement.prefab
    |   SceneChange.prefab
    |   SceneEnd.prefab
  +-- Scenes 1
    |   Title.prefab
  +-- Terrain
    |   Terrain.prefab
  +-- UI
    +-- Shopkeeper Buttons
    |   Button.prefab
    |   Canvas.prefab
    |   CountdownTMP.prefab
    |   DamageNumber.prefab
    |   DiagnosticCanvas.prefab
    |   HealthBar.prefab
    |   MainMenu.prefab
    |   Mobile Control UI.prefab
    |   Mobile Gamepad UI.prefab
    |   PlayerCanvas.prefab
    |   PlayerCurrencyCanvas.prefab
    |   Settings.prefab
    |   Shopkeeper Canvas.prefab
    |   ShopKeeper Trigger.prefab
    |   StaminaBar.prefab
    |   UI Canvas.prefab
    |   UpwardScrollingText.prefab
  +-- Weapons
    |   Firearms.prefab
    |   Grenades.prefab
    |   MeleeWeapons.prefab
+-- Resources
  +-- Controls
    |   PlayerControls.inputactions
  +-- ScriptableObjects
    |   BossEnemyLootTable.asset
    |   MajorEnemyLootTable.asset
    |   MinorEnemyLootTable.asset
  |   BillingMode.json
+-- Scenes
  +-- SteamScenes
    |   HeaderCapsule.unity
    |   LibraryCapsule.unity
    |   LibraryHero.unity
    |   LibraryLogo.unity
    |   MainCapsule.unity
    |   PageBackground.unity
    |   SmallCapsule.unity
    |   VerticalCapsule.unity
  +-- Test
    |   BossBrawl.unity
    |   New Terrain.asset
    |   TestObjectNamingStandardization.unity
  |   Credits.unity
  |   MetaShop.unity
  |   PermaShop.unity
  |   ReturnToStaging.unity
  |   SampleScene.unity
  |   SidePath1.unity
  |   Staging.unity
  |   Start.unity
  |   Title.unity
+-- Scripts
  +-- Cameras
    |   DynamicCameraAdjustment.cs
    |   SimpleCameraController.cs
  +-- Common
    |   Constants.cs
  +-- Core
    |   Fuzzy.cs
    |   HeapQueue.cs
    |   Simulation.cs
    |   Simulation.Event.cs
    |   Simulation.InstanceRegister.cs
  +-- DataManagement
    |   LoadSystem.cs
    |   PlayerData.cs
    |   PlayerSettings.cs
    |   SaveData.cs
    |   SaveSystem.cs
  +-- Debug
    |   AnimationDebugging.cs
    |   ControllerDebugging.cs
    |   PlayerActionDebugging.cs
  +-- Effects
    +-- Text
      |   FollowCharacter.cs
      |   FollowCharacterCamera.cs
      |   FollowCharacterController.cs
      |   Typewriter.cs
    +-- Visual
      |   DashAfterImage.cs
  +-- Events
    |   BaseGameEvent.cs
    |   BossDeath.cs
    |   BossJumped.cs
    |   BossLanded.cs
    |   BossStopJump.cs
    |   BossTransformationEvent.cs
    |   EnemyDeath.cs
    |   EnemyTerrainCollision.cs
    |   FadeInCamera.cs
    |   FadeOutCamera.cs
    |   HealthIsZero.cs
    |   LoadGame.cs
    |   PlayerBossCollision.cs
    |   PlayerCurrencyCollision.cs
    |   PlayerDeath.cs
    |   PlayerEnemyCollision.cs
    |   PlayerEnteredDeathZone.cs
    |   PlayerEnteredVictoryZone.cs
    |   PlayerExhausted.cs
    |   PlayerJumped.cs
    |   PlayerLanded.cs
    |   PlayerSpawn.cs
    |   PlayerStopJump.cs
    |   PlayerTerrainCollision.cs
    |   RestartScene.cs
    |   SaveGame.cs
    |   StaminaIsZero.cs
    |   WeaponBossCollision.cs
  +-- Gameplay
    |   GameTimer.cs
    |   SpawnPoint.cs
    |   TimeTrackerUI.cs
  +-- Items
    +-- Loot
      |   DropGroup.cs
      |   LootItem.cs
      |   LootTable.cs
    |   Collectible.cs
    |   HealthReplenishment.cs
    |   MetaCurrencyReplenishment.cs
    |   PermaCurrencyReplenishment.cs
  +-- Managers
    |   AudioManager.cs
    |   CameraTransformManager.cs
    |   DialogueManager.cs
    |   EnemyDefeatedManager.cs
    |   EventManager.cs
    |   GameControllerManager.cs
    |   LootDropManager.cs
    |   LootPurchaseManager.cs
    |   ManagerController.cs
    |   MonsterGroupActivationManager.cs
    |   PlayerCameraPositionManager.cs
    |   PlayerHealthUIManager.cs
    |   PlayerStaminaUIManager.cs
    |   RaycastManager.cs
    |   RestartSceneManager.cs
    |   SceneChangeManager.cs
    |   SceneExitAssignmentManager.cs
    |   SteamManager.cs
  +-- Mechanics
    +-- Audio
      |   PlayAudioClip.cs
    +-- Collectibles
      |   Buff.cs
      |   CurrencyInstance.cs
    +-- Colliders
      |   ParentCollider.cs
    +-- Controllers
      |   AllowZMovementController.cs
      |   BaseAction.cs
      |   BaseCurrencyController.cs
      |   Boss.cs
      |   CollisionController.cs
      |   Currency.cs
      |   DamageNumberController.cs
      |   Enemy.cs
      |   FlyingMajor.cs
      |   FlyingMinor.cs
      |   Game.cs
      |   KinematicObject.cs
      |   Major.cs
      |   MeleeController.cs
      |   MetaCurrencyController.cs
      |   Minor.cs
      |   PermaCurrencyController.cs
      |   Player.cs
      |   PlayerAction.cs
      |   PlayerUnlock.cs
      |   PortalSpawnController.cs
      |   ProjectileController.cs
      |   RangedAttackController.cs
      |   SceneChangeController.cs
      |   SceneEndController.cs
      |   ShopKeeperWindow.cs
    +-- Currency
      |   BaseCurrency.cs
      |   Meta.cs
      |   Perma.cs
    +-- Enums
      |   Achievements.cs
      |   ActionStates.cs
      |   Animations.cs
      |   Bosses.cs
      |   BuffTypes.cs
      |   Directions.cs
      |   GameStates.cs
      |   Layers.cs
      |   MonsterStates.cs
      |   PlayerAnimationLayers.cs
      |   Scenes.cs
      |   SceneSizes.cs
      |   Tags.cs
      |   UnlockTypes.cs
    +-- Loot
      |   LootHelper.cs
    +-- Patrol
      |   PatrolPath.cs
      |   PatrolPath.Mover.cs
    +-- Stats
      |   BaseStat.cs
      |   Health.cs
      |   Stamina.cs
    +-- Zones
      |   DeathZone.cs
      |   VictoryZone.cs
    |   BossTransformations.cs
  +-- Models
    |   Firearms.cs
    |   MeleeWeapons.cs
    |   MonsterGroups.cs
    |   Platformer.cs
    |   Unlock.cs
    |   UnlockScriptableObject.cs
  +-- Performance
    |   PerformanceProfiler.cs
  +-- Steam
    |   Achievement.cs
    |   StatsAndAchievements.cs
  +-- UI
    |   AutoVerticalScrollText.cs
    |   BossesDefeatedUIDisplayManager.cs
    |   HealthBar.cs
    |   MainUIController.cs
    |   MetaGameController.cs
    |   StaminaBar.cs
    |   StatUI.cs
    |   TitleScreen.cs
  +-- Utilities
    +-- Editor
      +-- RenamingHelpers
        |   RecalculateObjectNames.cs
        |   RemoveAppendedCounts.cs
        |   RemoveNumericSuffix.cs
      |   AnimatorTransitionChanger.cs
      |   BuildReportGenerator.cs
      |   DeleteAllTransitions.cs
      |   WebGLExcludeRemover.cs
    |   AchevementResolver.cs
    |   ButtonHelper.cs
    |   ChildObjectsAnimationSynchronization.cs
    |   CoroutineRunner.cs
    |   PlatformVisibilityController.cs
    |   SceneEnumResolver.cs
    |   TimedLogger.cs
    |   WebGLExclude.cs
  +-- WebRequests
    |   WebRequestHandler.cs
+-- Settings
  |   Balanced_PipelineAsset.asset
  |   Balanced_PipelineAsset_ForwardRenderer.asset
  |   SampleSceneProfile.asset
  |   URP-Balanced-Renderer.asset
  |   URP-Balanced.asset
  |   URP-HighFidelity-Renderer.asset
  |   URP-HighFidelity.asset
  |   URP-Performant-Renderer.asset
  |   URP-Performant.asset
+-- Terrain
  |   New Terrain.asset
  |   Plain.asset
+-- TextMesh Pro
  +-- Fonts
    |   LiberationSans - OFL.txt
    |   LiberationSans.ttf
  +-- Resources
    +-- Fonts & Materials
      |   LiberationSans SDF - Drop Shadow.mat
      |   LiberationSans SDF - Fallback.asset
      |   LiberationSans SDF - Outline.mat
      |   LiberationSans SDF.asset
    +-- Sprite Assets
      |   EmojiOne.asset
    +-- Style Sheets
      |   Default Style Sheet.asset
    |   LineBreaking Following Characters.txt
    |   LineBreaking Leading Characters.txt
    |   TMP Settings.asset
  +-- Shaders
    |   SDFFunctions.hlsl
    |   TMPro.cginc
    |   TMPro_Mobile.cginc
    |   TMPro_Properties.cginc
    |   TMPro_Surface.cginc
    |   TMP_Bitmap-Custom-Atlas.shader
    |   TMP_Bitmap-Mobile.shader
    |   TMP_Bitmap.shader
    |   TMP_SDF Overlay.shader
    |   TMP_SDF SSD.shader
    |   TMP_SDF-HDRP LIT.shadergraph
    |   TMP_SDF-HDRP UNLIT.shadergraph
    |   TMP_SDF-Mobile Masking.shader
    |   TMP_SDF-Mobile Overlay.shader
    |   TMP_SDF-Mobile SSD.shader
    |   TMP_SDF-Mobile-2-Pass.shader
    |   TMP_SDF-Mobile.shader
    |   TMP_SDF-Surface-Mobile.shader
    |   TMP_SDF-Surface.shader
    |   TMP_SDF-URP Lit.shadergraph
    |   TMP_SDF-URP Unlit.shadergraph
    |   TMP_SDF.shader
    |   TMP_Sprite.shader
  +-- Sprites
    |   EmojiOne Attribution.txt
    |   EmojiOne.json
    |   EmojiOne.png
|   DefaultVolumeProfile.asset
|   GenerateStructure.ps1
|   solution_structure.txt
|   UniversalRenderPipelineGlobalSettings.asset

===== Printing Requested Script Contents =====


/***********************/
/** Player.cs **/
/***********************/

using Michsky.MUIP;
using NeonLadder.Common;
using NeonLadder.Mechanics.Currency;
using NeonLadder.Mechanics.Enums;
using NeonLadder.Mechanics.Stats;
using NeonLadder.Utilities;
using System;
using UnityEngine;
using UnityEngine.InputSystem;

namespace NeonLadder.Mechanics.Controllers
{
    public class Player : KinematicObject
    {
        [SerializeField]
        private ProgressBar HealthBar;
        [SerializeField]
        private ProgressBar StaminaBar;
        public AudioSource audioSource;
        public AudioClip respawnAudio;
        public AudioClip ouchAudio;
        public AudioClip jumpAudio;
        public AudioClip landOnGroundAudio;
        public AudioClip landOnEnemyAudio;

        public bool IsFacingLeft { get; set; }
        public bool IsFacingRight => !IsFacingLeft;

        public PlayerAction Actions { get; private set; }
        public PlayerUnlock Unlocks { get; private set; }
        public Health Health { get; private set; }
        public Stamina Stamina { get; private set; }
        public Meta MetaCurrency { get; private set; }
        public Perma PermaCurrency { get; private set; }
        [SerializeField]
        private InputActionAsset controls;
        public InputActionAsset Controls
        {
            get { return controls; }
            set { controls = value; }
        }
        [SerializeField]
        public float staminaRegenTimer = 0f;

        public override bool IsUsingMelee { get; set; } = true;

        private int walkAnimation = 6;
        private int runAnimation = 10;
        private int idleAnimation = 1;
        private int jumpAnimation = 11;
        private int fallAnimation = 12;
        private int rollAnimation = 13;

        protected override void OnEnable()
        {
            base.OnEnable();
        }

        public void Spawn(Transform location)
        {
            transform.parent.position = location.position;
        }

        protected override void Awake()
        {
            base.Awake();
            Actions = GetComponent<PlayerAction>();
            Unlocks = GetComponent<PlayerUnlock>();
            audioSource = GetComponentInParent<AudioSource>();
            rigidbody = GetComponentInParent<Rigidbody>();
            Health = GetComponentInParent<Health>();
            Stamina = GetComponentInParent<Stamina>();
            HealthBar = transform.parent.GetComponentInChildren<HealthBar>().gameObject.GetComponent<ProgressBar>();
            StaminaBar = transform.parent.GetComponentInChildren<StaminaBar>().gameObject.GetComponent<ProgressBar>();
            MetaCurrency = GetComponentInParent<Meta>();
            PermaCurrency = GetComponentInParent<Perma>();
            
            if (controls == null)
            {
                controls = Resources.Load<InputActionAsset>("Controls/PlayerControls");
            }
        }

        protected override void FixedUpdate()
        {
            base.FixedUpdate();
            if (IsGrounded)
            {
                Actions.ResetJumpCount();
            }
        }

        protected override void Update()
        {
            //do we need this?
            IsFacingLeft = transform.parent.rotation.eulerAngles.y == 270;
            
            //TimedLogger.Log($"Player transform position: {transform.position}", 1f);
            base.Update();
            if (Health.IsAlive)
            {
                HandleAnimations();
                RegenerateStamina();
            }

            UpdateHealthBar();
            UpdateStaminaBar();

            
        }

        private void RegenerateStamina()
        {
            staminaRegenTimer += Time.deltaTime;
            if (staminaRegenTimer >= 0.1f) // Check if 1/10th of a second has passed
            {
                Stamina.Increment(0.1f); // Increment stamina by 1/10th of a unit
                staminaRegenTimer -= 0.1f; // Decrease the timer by 0.1f instead of resetting to 0
            }
        }

        protected override void ComputeVelocity()
        {
            if (!Health.IsAlive)
            {
                targetVelocity = Vector3.zero;
            }
            else if (!rigidbody.constraints.HasFlag(RigidbodyConstraints.FreezePositionZ))
            {
                targetVelocity.z = Constants.DefaultMaxSpeed / 2;
            }
            else
            {
                targetVelocity.x = Actions.playerInput.x * Constants.DefaultMaxSpeed * ((Actions?.IsSprinting ?? false) ? Constants.SprintSpeedMultiplier : 1);

                // Handle jumping
                if (Actions.isJumping && Actions.JumpCount < Actions.MaxJumps) 
                {
                    velocity.y = Actions.jumpForce;
                    Actions.IncrementJumpCount();
                    Actions.isJumping = false;
                    if (audioSource != null && jumpAudio != null)
                    {
                        audioSource.PlayOneShot(jumpAudio);
                    }
                }
            }
        }

        public void EnableZMovement()
        {
            transform.parent.rotation = Quaternion.Euler(0, 0, 0);
            Actions.playerActionMap.Disable();
            rigidbody.constraints = RigidbodyConstraints.FreezeRotation |
                                    RigidbodyConstraints.FreezePositionX |
                                    RigidbodyConstraints.FreezePositionY;
        }

        public void DisableZMovement()
        {
            targetVelocity.z = 0;
            Actions.playerActionMap.Enable();
            rigidbody.constraints = RigidbodyConstraints.FreezePositionZ;
        }

        private void HandleAnimations()
        {
            if (animator.GetInteger(nameof(PlayerAnimationLayers.locomotion_animation)) > 9000 || animator.GetInteger(nameof(PlayerAnimationLayers.locomotion_animation)) == 5) // dances, death
            {
                return;
            }

            HandleLocomotion();
        }

        private void HandleLocomotion()
        {
            if (velocity.y > 2)
            {
                if (Actions.JumpCount == 2)
                {
                    animator.SetInteger(nameof(PlayerAnimationLayers.locomotion_animation), rollAnimation); // roll
                }
                else
                {
                    animator.SetInteger(nameof(PlayerAnimationLayers.locomotion_animation), jumpAnimation); // jump
                }
            }
            else if (velocity.y < -2)
            {
                animator.SetInteger(nameof(PlayerAnimationLayers.locomotion_animation), fallAnimation); // fall
            }
            else if (Math.Abs(velocity.x) < 0.1 && Math.Abs(velocity.z) < 0.1)
            {
                animator.SetInteger(nameof(PlayerAnimationLayers.locomotion_animation), idleAnimation); // idle
            }
            else if (Math.Abs(velocity.x) > 4 || Math.Abs(velocity.z) > 4)
            {
                animator.SetInteger(nameof(PlayerAnimationLayers.locomotion_animation), runAnimation); // run
            }
            else if (Math.Abs(velocity.x) > 0.1 || Math.Abs(velocity.z) > 0.1)
            {
                animator.SetInteger(nameof(PlayerAnimationLayers.locomotion_animation), walkAnimation); // walk
            }
        }


        internal void AddMetaCurrency(int amount)
        {
            MetaCurrency.Increment(amount);
        }

        internal void AddPermanentCurrency(int amount)
        {
            PermaCurrency.Increment(amount);
        }

        private void UpdateHealthBar()
        {
            if (HealthBar != null && Health != null)
            {
                HealthBar.currentPercent = (Health.current / Health.max) * 100f;
            }
        }
        private void UpdateStaminaBar()
        {
            if (StaminaBar != null && Stamina != null)
            {
                StaminaBar.currentPercent = (Stamina.current / Stamina.max) * 100f;
            }
        }
    }
}

/***********************/
/** Enemy.cs **/
/***********************/

using NeonLadder.Common;
using NeonLadder.Items.Loot;
using NeonLadder.Mechanics.Enums;
using NeonLadder.Mechanics.Stats;
using NeonLadder.Utilities;
using System.Collections;
using System.Linq;
using UnityEngine;

namespace NeonLadder.Mechanics.Controllers
{
    public abstract class Enemy : KinematicObject
    {
        public bool ShouldEngagePlayer = true; // Publicly accessible flag, default to always engage.
        public AudioSource audioSource;
        public AudioClip respawnAudio;
        public AudioClip ouchAudio;
        public AudioClip jumpAudio;
        public AudioClip landAudio;
        private int moveDirection;

        public bool IsFacingLeft { get; set; }
        public bool IsFacingRight => !IsFacingLeft;

        [SerializeField]
        private LootTable lootTable; // Allow assignment in the editor
        private LootTable runtimeLootTable;
        public LootTable RuntimeLootTable
        {
            get { return runtimeLootTable; }
            private set { runtimeLootTable = value; }
        }

        public Health health { get; private set; }
        public Stamina stamina { get; private set; }
        [SerializeField]
        public float staminaRegenTimer = 0f;

        [SerializeField]
        protected virtual int attackDamage { get; set; } = 10; // Damage per attack

        public float deathBuffer = 1f;

        [SerializeField]
        private float attackRange = 0f; // Default value

        [SerializeField]
        private bool retreatWhenTooClose = false; // Default value

        protected virtual float AttackRange
        {
            get
            {
                if (attackRange > 0)
                {
                    return attackRange;
                }
                else
                {
                    BoxCollider boxCollider = GetComponentInParent<BoxCollider>();
                    return boxCollider != null ? boxCollider.size.x / 2 + 1.0f : 3.0f; // Default value if no BoxCollider found
                }
            }
            set { attackRange = value; }
        }

        protected virtual bool RetreatWhenTooClose
        {
            get { return retreatWhenTooClose; }
            set { retreatWhenTooClose = value; }
        }

        [SerializeField]
        private MonsterStates currentState = MonsterStates.Idle;
        [SerializeField]
        protected virtual float retreatBuffer { get; set; } = 1.0f;
        [SerializeField]
        private float _attackCooldown = 3.0f; // Default value if not set in the editor or overridden

        public virtual float attackCooldown
        {
            get => _attackCooldown;
            set => _attackCooldown = value;
        }
        protected virtual float lastAttackTime { get; set; } = -10f;
        protected virtual int idleAnimation { get; set; } = 0;
        protected virtual int walkForwardAnimation { get; set; } = 1;
        protected virtual int walkBackwardAnimation { get; set; } = 6;
        protected virtual int attackAnimation { get; set; } = 2;
        protected virtual int hurtAnimation { get; set; } = 3;
        protected virtual int victoryAnimation { get; set; } = 5;
        protected virtual int deathAnimation { get; set; } = 4;

        private bool isIdlePlaying = false;

        protected override void Awake()
        {
            if (attackCooldown <= attackAnimationDuration)
            {
                Debug.LogWarning($"Attack cooldown is less than or equal to attack animation duration for enemy: {transform.parent.name}");
            }
            base.Awake();
            health = GetComponentInParent<Health>();
            if (lootTable == null)
            {
                RuntimeLootTable = LootHelper.LoadLootTable(this);
            }
        }

        protected override void ComputeVelocity()
        {
            base.ComputeVelocity();
            if (health.IsAlive)
            {
                if (moveDirection != 0)
                {
                    targetVelocity.x = moveDirection * Constants.DefaultMaxSpeed;
                }

                if (currentState == MonsterStates.Retreating)
                {
                    targetVelocity.x = targetVelocity.x / 2;
                }

                velocity.x = targetVelocity.x;  // Apply horizontal movement
            }
        }

        protected override void Update()
        {
            float distanceToTarget = Vector3.Distance(transform.parent.position, player.transform.parent.position);
            IsFacingLeft = player.transform.parent.position.x < transform.parent.position.x;
            if (health.IsAlive)
            {
                Orient();
            }

            if (ShouldEngagePlayer && !isIdlePlaying)
            {
                
                base.Update();
                if (health.IsAlive)
                {
                    if (ShouldEngagePlayer && player.Health.IsAlive)
                    {
                        //if (currentState != MonsterStates.Attacking)
                        //{
                            switch (currentState)
                            {
                                case MonsterStates.Idle:
                                    StartCoroutine(PlayIdleAndReassess(distanceToTarget));
                                    break;
                                case MonsterStates.Reassessing:
                                    HandleReassessingState(distanceToTarget);
                                    break;
                                case MonsterStates.Approaching:
                                    HandleApproachingState(distanceToTarget);
                                    break;
                                case MonsterStates.Retreating:
                                    HandleRetreatingState(distanceToTarget);
                                    break;
                                case MonsterStates.Attacking:
                                    StartCoroutine(AttackPlayer());
                                    isIdlePlaying = false; // Ensure idle animation stops
                                    break;
                            }
                        //}
                    }
                }
                else
                {
                    StartCoroutine(PlayDeathAnimation());
                    isIdlePlaying = false; // Ensure idle animation stops
                }
            }
            else
            {
                //play victory animation
                StartCoroutine(PlayVictoryAnimation());
            }
        }

        private IEnumerator PlayIdleAndReassess(float distanceToTarget)
        {
            // Reassess state first
            ReassessState(distanceToTarget);

            // If state is still idle, play idle animation
            if (currentState == MonsterStates.Idle)
            {
                isIdlePlaying = true;
                moveDirection = 0;
                animator.SetInteger("animation", idleAnimation);
                Debug.Log($"{transform.parent.name} starting Idle animation. Expected duration: {idleAnimationDuration}");
                yield return new WaitForSeconds(idleAnimationDuration);
                Debug.Log($"{transform.parent.name} completed Idle animation.");
                isIdlePlaying = false;
                ReassessState(distanceToTarget);
            }
        }

        private void ReassessState(float distanceToTarget)
        {
            if (distanceToTarget > AttackRange)
            {
                currentState = MonsterStates.Approaching;
            }
            else if (RetreatWhenTooClose && distanceToTarget < (AttackRange - retreatBuffer))
            {
                currentState = MonsterStates.Retreating;
            }
            else if (Time.time > lastAttackTime + attackCooldown)
            {
                currentState = MonsterStates.Attacking;
            }
            else
            {
                currentState = MonsterStates.Reassessing; // Stay idle if no other actions are required
            }
        }

        private void HandleReassessingState(float distanceToTarget)
        {
            if (distanceToTarget > AttackRange)
            {
                currentState = MonsterStates.Approaching;
                isIdlePlaying = false; // Ensure idle animation stops
            }
            else if (RetreatWhenTooClose && distanceToTarget < (AttackRange - retreatBuffer))
            {
                currentState = MonsterStates.Retreating;
                isIdlePlaying = false; // Ensure idle animation stops
            }
            else if (Time.time > lastAttackTime + attackCooldown)
            {
                currentState = MonsterStates.Attacking;
                isIdlePlaying = false; // Ensure idle animation stops
            }
            else
            {
                if (!isIdlePlaying)
                {
                    //Debug.Log($"{transform.parent.name} entering Reassessing state.");
                    StartCoroutine(PlayIdleAnimation());
                }
            }
        }

        private void HandleApproachingState(float distanceToTarget)
        {
            if (distanceToTarget <= AttackRange)
            {
                currentState = MonsterStates.Reassessing;
                if (!isIdlePlaying)
                {
                    StartCoroutine(PlayIdleAnimation());
                }
            }
            else
            {
                moveDirection = IsFacingLeft ? -1 : 1; // Move towards the player
                animator.SetInteger("animation", walkForwardAnimation);
                isIdlePlaying = false; // Ensure idle animation stops
            }
        }

        private void HandleRetreatingState(float distanceToTarget)
        {
            if (distanceToTarget >= AttackRange - retreatBuffer)
            {
                currentState = MonsterStates.Reassessing;
                if (!isIdlePlaying)
                {
                    StartCoroutine(PlayIdleAnimation());
                }
            }
            else
            {
                Retreat();
                isIdlePlaying = false; // Ensure idle animation stops
                animator.SetInteger("animation", walkBackwardAnimation);
            }
        }

        private IEnumerator PlayIdleAnimation()
        {
            isIdlePlaying = true;
            moveDirection = 0;
            animator.SetInteger("animation", idleAnimation);
            //Debug.Log($"{transform.parent.name} starting Idle animation. Expected duration: {idleAnimationDuration}");

            if (Vector3.Distance(transform.parent.position, player.transform.parent.position) <= AttackRange && Time.time > lastAttackTime + attackCooldown)
            {
                //Debug.Log($"{transform.parent.name} interrupting Idle animation to attack.");
                isIdlePlaying = false;
                currentState = MonsterStates.Attacking;
                //StartCoroutine(AttackPlayer());
                yield break;
            }

            isIdlePlaying = false;
            //ReassessState(Vector3.Distance(transform.parent.position, player.transform.parent.position));
        }

        private void Retreat()
        {
            moveDirection = IsFacingLeft ? 1 : -1;
            animator.SetInteger("animation", walkBackwardAnimation);
        }

        private IEnumerator PlayVictoryAnimation()
        {
            animator.SetInteger("animation", victoryAnimation);
            yield return new WaitForSeconds(victoryAnimationDuration);
            //animator.SetInteger("animation", idleAnimation);
        }

        private IEnumerator PlayDeathAnimation()
        {
            animator.SetInteger("animation", deathAnimation);
            yield return new WaitForSeconds(deathAnimationDuration);
            transform.parent.gameObject.SetActive(false);
        }

        private IEnumerator AttackPlayer()
        {
            var attackComponents = transform.parent.gameObject.GetComponentsInChildren<Collider>()
                                                              .Where(c => c.gameObject != transform.parent.gameObject).ToList();
            if (attackComponents != null && attackComponents.Count() > 0)
            {
                lastAttackTime = Time.time;
                foreach (var attackComponent in attackComponents)
                {
                    attackComponent.gameObject.layer = LayerMask.NameToLayer(nameof(Layers.Battle));
                }

                animator.SetInteger("animation", attackAnimation);
                yield return new WaitForSeconds(attackAnimationDuration);

                foreach (var attackComponent in attackComponents)
                {
                    attackComponent.gameObject.layer = LayerMask.NameToLayer(nameof(Layers.Default));
                }

                //currentState = MonsterStates.Reassessing;
            }
            //else
            //{
            //    Debug.LogWarning($"No attack components found for enemy: {transform.parent.name} -> Resorting to {nameof(FallbackAttack)}");
            //    if (Time.time > lastAttackTime + attackCooldown)
            //    {
            //        yield return StartCoroutine(FallbackAttack());
            //    }
            //}
            ReassessState(Vector3.Distance(transform.parent.position, player.transform.parent.position));
        }

        //private IEnumerator FallbackAttack()
        //{
        //    lastAttackTime = Time.time;
        //    player.Health.Decrement(attackDamage);
        //    animator.SetInteger("animation", attackAnimation);
        //    yield return new WaitForSeconds(attackAnimationDuration);
        //    currentState = MonsterStates.Reassessing;
        //}

        public void Orient()
        {
            transform.parent.rotation = Quaternion.Euler(0, !IsFacingLeft ? 90 : -90, 0);
        }

        private void ChasePlayer()
        {
            moveDirection = IsFacingLeft ? -1 : 1;
            animator.SetInteger("animation", walkForwardAnimation);
        }
    }
}

/***********************/
/** Boss.cs **/
/***********************/

using UnityEngine;

namespace NeonLadder.Mechanics.Controllers
{
    public class Boss : Enemy
    {
        public GameObject transformation;

        protected override void Start()
        {
            if (BossTransformations.bossTransformations.ContainsKey(gameObject.transform.parent.name))
            {
                var transformationName = BossTransformations.bossTransformations[gameObject.transform.parent.name];
                if (gameObject.transform.parent.name != transformationName)
                {
                    transformation = GameObject.Find(transformationName);

                    if (transformation != null)
                    {
                        transformation.SetActive(false);
                    }
                    else
                    {
                        Debug.LogError($"Transformation game object '{transformationName}' not found.");
                    }
                }
            }
            base.Start();
        }
    }
}

/***********************/
/** Game.cs **/
/***********************/

using NeonLadder.Core;
using NeonLadder.Models;
using UnityEngine;
using UnityEngine.SceneManagement;

namespace NeonLadder.Mechanics.Controllers
{
    /// <summary>
    /// This class exposes the game model in the inspector, and ticks the
    /// simulation.
    /// </summary> 
    public class Game : MonoBehaviour
    {
        public static Game Instance { get; private set; }

        public PlatformerModel model = Simulation.GetModel<PlatformerModel>();

        void Awake()
        {
            if (Instance != null && Instance != this)
            {
                Destroy(gameObject);
                return;
            }

            Instance = this;
            DontDestroyOnLoad(gameObject);
        }

        void OnEnable()
        {
            if (Instance == null)
            {
                Instance = this;
                DontDestroyOnLoad(gameObject);
            }
        }

        void OnDisable()
        {
            if (Instance == this) Instance = null;
        }

        void Update()
        {
            if (Instance == this) Simulation.Tick();
        }

        public void DestroyGameInstance()
        {
            if (Instance != null)
            {
                Destroy(Instance.gameObject);
                Instance = null;
            }
        }

    }
}

/***********************/
/** GameControllerManager.cs **/
/***********************/

using Cinemachine;
using NeonLadder.Events;
using NeonLadder.Mechanics.Controllers;
using NeonLadder.Mechanics.Enums;
using NeonLadder.UI;
using NeonLadder.Utilities;
using UnityEngine;
using UnityEngine.SceneManagement;
using static NeonLadder.Core.Simulation;

public class GameControllerManager : MonoBehaviour
{
    private Game gameController;
    private Player player;
    private PlayerAction playerActions;
    private Scenes scene;

    // Start is called before the first frame update
    void Start()
    {
        scene = SceneEnumResolver.Resolve(SceneManager.GetActiveScene().name);
        InitializeControllers();
        AdjustControllersBasedOnScene();
    }

    private void Awake()
    {
        enabled = false;
    }

    void Update()
    {
        if (SceneManager.GetActiveScene().name != scene.ToString())
        {
            scene = SceneEnumResolver.Resolve(SceneManager.GetActiveScene().name);
            InitializeControllers();
            AdjustControllersBasedOnScene();
        }
    }

    private void InitializeControllers()
    {
        if (scene == Scenes.Title)
        {
            if (player == null)
            {
                player = GameObject.FindGameObjectWithTag(Tags.Player.ToString()).GetComponentInChildren<Player>();
                if (player == null)
                {
                    Debug.LogError("Player not found in scene.");
                }
            }

            if (playerActions == null)
            {
                playerActions = player.GetComponent<PlayerAction>();
                if (playerActions == null)
                {
                    Debug.LogError("PlayerAction not found in scene.");
                }
            }
        }

        else if (scene != Scenes.Credits)
        {
            if (gameController == null)
            {
                var gameControllerObj = GameObject.FindGameObjectWithTag(Tags.GameController.ToString());
                if (gameControllerObj != null)
                {
                    gameController = gameControllerObj.GetComponent<Game>();
                }
                if (gameController == null)
                {
                    Debug.LogError("GameController not found in scene.");
                }
            }

            if (player == null)
            {
                player = gameController.GetComponentInChildren<Player>();
                if (player == null)
                {
                    Debug.LogError("Player not found in scene.");
                }
            }

            if (playerActions == null)
            {
                playerActions = player.GetComponent<PlayerAction>();
                if (playerActions == null)
                {
                    Debug.LogError("PlayerAction not found in scene.");
                }
            }
        }
    }

    public void AdjustControllersBasedOnScene()
    {
        switch (scene)
        {
            case Scenes.Title:
                player.transform.parent.GetComponentInChildren<Canvas>().enabled = false;
                playerActions.enabled = false;
                break;
            case Scenes.Staging:
                player.transform.parent.GetComponentInChildren<Canvas>().enabled = true;
                Schedule<LoadGame>();
                Game.Instance.model.VirtualCamera.GetCinemachineComponent<CinemachineFramingTransposer>().m_CameraDistance = 6;
                gameController.gameObject.GetComponent<MetaGameController>().enabled = false;
                gameController.gameObject.GetComponent<MetaGameController>().enabled = true;
                break;
            case Scenes.ReturnToStaging:
                player.transform.parent.GetComponentInChildren<Canvas>().enabled = false;
                break;
            case Scenes.Start:
            case Scenes.SidePath1:
                Game.Instance.model.VirtualCamera.GetCinemachineComponent<CinemachineFramingTransposer>().m_CameraDistance = 6;
                break;
            case Scenes.MetaShop:
                Game.Instance.model.VirtualCamera.GetCinemachineComponent<CinemachineFramingTransposer>().m_CameraDistance = 2.2f;
                break;
            case Scenes.PermaShop:
                Game.Instance.model.VirtualCamera.GetCinemachineComponent<CinemachineFramingTransposer>().m_CameraDistance = 2.2f;
                break;
            case Scenes.Credits:
                break;
            default:
                playerActions.enabled = true;
                gameController.gameObject.SetActive(true);
                Game.Instance.model.VirtualCamera.GetCinemachineComponent<CinemachineFramingTransposer>().m_CameraDistance = 6;
                break;
        }
    }
}

/***********************/
/** SceneChangeController.cs **/
/***********************/

using NeonLadder.Core;
using NeonLadder.Managers;
using NeonLadder.Mechanics.Controllers;
using NeonLadder.Mechanics.Enums;
using NeonLadder.Models;
using UnityEngine;
using UnityEngine.SceneManagement;

public class SceneChangeController : MonoBehaviour
{
    public string SceneName;
    private PlatformerModel model;
    private Player player;
    private PlayerCameraPositionManager playerAndCameraPositionManager;

    private void Awake()
    {
        model = Simulation.GetModel<PlatformerModel>();
        player = model.Player;
        playerAndCameraPositionManager = GameObject.FindGameObjectWithTag(Tags.Managers.ToString()).GetComponentInChildren<PlayerCameraPositionManager>();
        SceneManager.sceneLoaded += OnSceneLoaded;
    }

    private void OnDisable()
    {
        SceneManager.sceneLoaded -= OnSceneLoaded;
    }

    private void OnTriggerEnter(Collider collision)
    {
        if (collision.CompareTag(Tags.Player.ToString()))
        {
            model.VirtualCamera.enabled = false;
            SceneManager.LoadScene(SceneName); //breakpoint here
        }
    }

    private void OnSceneLoaded(Scene scene, LoadSceneMode mode)
    {
        if (player == null)
        {
            return;
        }

        player.DisableZMovement();

        Vector3 playerPosition;
        Vector3 cameraPosition;
        Quaternion cameraRotation;

        if (playerAndCameraPositionManager.TryGetState(scene.name, out playerPosition, out cameraPosition, out cameraRotation))
        {
            player.Teleport(playerPosition);
            GameObject.FindGameObjectWithTag(Tags.MainCamera.ToString()).transform.position = cameraPosition;
        }
        else
        {
            GameObject spawnPoint = GameObject.FindGameObjectWithTag(Tags.SpawnPoint.ToString());
            if (spawnPoint != null)
            {
                //Debug.Log($"Current Player position: {player.transform.position} -> SpawnPoint found in the scene: {spawnPoint.transform.position}");
                if (player.transform.parent.position != spawnPoint.transform.position)
                {
                    //Debug.Log("Teleporting player to SpawnPoint position.");
                    player.Teleport(spawnPoint.transform.position);
                    //player.Actions.transform.position = spawnPoint.transform.position;
                }
                //player.transform.position = spawnPoint.transform.position;
            }
            else
            {
                Debug.LogWarning("No SpawnPoint found in the scene.");
            }
        }
        model.VirtualCamera.enabled = true;
        player.transform.parent.rotation = Quaternion.Euler(0, 90, 0);
        if (player.transform.parent.position.y < 0)
        {
            player.transform.parent.position = new Vector3(player.transform.parent.position.x, 0.01f, player.transform.parent.position.z);
        }

        SceneManager.sceneLoaded -= OnSceneLoaded;
    }
}

/***********************/
/** SaveSystem.cs **/
/***********************/

using NeonLadderURP.Models;
using System.Collections.Generic;
using System.IO;
using UnityEngine;

namespace NeonLadderURP.DataManagement
{
    public static class SaveSystem
    {
        private const string SaveFileName = "playerData.json";

        public static void Save(PlayerData data)
        {
            string json = JsonUtility.ToJson(data);
            // Optionally encrypt json here
            File.WriteAllText(Path.Combine(Application.persistentDataPath, SaveFileName), json);
        }

        public static bool SaveExists()
        {
            return File.Exists(Path.Combine(Application.persistentDataPath, SaveFileName));
        }   

        public static PlayerData Load()
        {
            string path = Path.Combine(Application.persistentDataPath, SaveFileName);
            if (File.Exists(path))
            {
                string json = File.ReadAllText(path);
                // Optionally decrypt json here
                return JsonUtility.FromJson<PlayerData>(json);
            }
            return new PlayerData { Unlocks = new List<Unlock>(), Settings = new PlayerSettings() };
        }
    }
}

/***********************/
/** AudioManager.cs **/
/***********************/

using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

[System.Serializable]
public class BossTrack
{
    public int bossId;
    public AudioClip intro;
    public AudioClip loop;
    public AudioClip outro;
}

public interface IAudioManager
{
    void PlayBackgroundTrack();
    void PlayBossTrack(int bossId);
}


public class AudioManager : MonoBehaviour, IAudioManager
{
    public List<AudioClip> backgroundTracks;
    public List<BossTrack> bossTracks;
    public AudioClip PlayerMotivation;
    public AudioClip BossIntroReveal;
    private AudioSource audioSource;

    void Start()
    {
        audioSource = GetComponent<AudioSource>();
        PlayBackgroundTrack();
    }

    public void PlayBackgroundTrack()
    {
        AudioClip selectedTrack = backgroundTracks[Random.Range(0, backgroundTracks.Count)];
        audioSource.clip = selectedTrack;
        audioSource.loop = true;
        audioSource.Play();
    }

    public void SetVolume(float volume)
    {
        if (audioSource != null)
        {
            audioSource.volume = volume;
        }
    }
    public void PlayBossTrack(int bossId)
    {
        StopAllCoroutines();
        StartCoroutine(BossIntro(bossId));
    }

    private IEnumerator BossIntro(int bossId)
    {
        var track = bossTracks.Single(bt => bt.bossId == bossId);
        audioSource.Stop();
        audioSource.clip = track.intro;
        audioSource.loop = false;
        audioSource.Play();
        yield return new WaitForSeconds(track.intro.length - 0.5f);
        
        BossMidFight(bossId);
    }

    private void BossMidFight(int bossId)
    {
        var track = bossTracks[bossId];
        audioSource.clip = track.loop;
        audioSource.loop = true;
        audioSource.Play();
    }
}

/***********************/
/** ManagerController.cs **/
/***********************/

using NeonLadder.Mechanics.Enums;
using NeonLadder.Utilities;
using UnityEngine;
using UnityEngine.SceneManagement;

namespace NeonLadder.Managers
{
    public class ManagerController : MonoBehaviour
    {
        public static ManagerController Instance;
        [SerializeField] private bool dontDestroyOnLoad = true;

        private Scenes scene;
        public EnemyDefeatedManager enemyDefeatedManager;
        public DialogueManager dialogueManager;
        public SceneExitAssignmentManager sceneExitAssignmentManager;
        public LootDropManager lootDropManager;
        public LootPurchaseManager lootPurchaseManager;
        public MonsterGroupActivationManager monsterGroupActivationManager;
        public PlayerCameraPositionManager playerCameraPositionManager;
        public GameControllerManager gameControllerManager;
        public SceneChangeManager sceneChangeManager;
        public EventManager eventManager;
        public SteamManager steamManager;

        void Awake()
        {
            InitializeChildComponents();

            if (Instance != null && Instance != this)
            {
                Destroy(gameObject);
            }
            else
            {
                Instance = this;
                if (dontDestroyOnLoad)
                {
                    DontDestroyOnLoad(gameObject);
                }

            }
        }

        void Start()
        {
            scene = SceneEnumResolver.Resolve(SceneManager.GetActiveScene().name);
            ToggleManagers();
        }

        private void Update()
        {
            if (SceneManager.GetActiveScene().name != scene.ToString())
            {
                scene = SceneEnumResolver.Resolve(SceneManager.GetActiveScene().name);
                ToggleManagers();
            }
        }

        private void InitializeChildComponents()
        {
            enemyDefeatedManager = GetComponentInChildren<EnemyDefeatedManager>();
            sceneExitAssignmentManager = GetComponentInChildren<SceneExitAssignmentManager>();
            lootDropManager = GetComponentInChildren<LootDropManager>();
            lootPurchaseManager = GetComponentInChildren<LootPurchaseManager>();
            playerCameraPositionManager = GetComponentInChildren<PlayerCameraPositionManager>();
            gameControllerManager = GetComponentInChildren<GameControllerManager>();
            sceneChangeManager = GetComponentInChildren<SceneChangeManager>();
            dialogueManager = GetComponentInChildren<DialogueManager>();
            eventManager = GetComponentInChildren<EventManager>();
            monsterGroupActivationManager = GetComponentInChildren<MonsterGroupActivationManager>();
            steamManager = GetComponentInChildren<SteamManager>();
        }

        public void ToggleManagers()
        {
            eventManager.enabled = true;
            switch (scene)
            {
                case Scenes.Title:
                    gameControllerManager.enabled = true;
                    //steamManager.enabled = true;
                    break;
                case Scenes.Staging:
                    lootPurchaseManager.enabled = true;
                    playerCameraPositionManager.enabled = true;
                    playerCameraPositionManager.EmptySceneStates();
                    if (monsterGroupActivationManager != null)
                    {
                        monsterGroupActivationManager.enabled = false;
                    }
                    break;
                case Scenes.Start:
                case Scenes.Recife_2050_Final:
                    if (monsterGroupActivationManager != null)
                    {
                        monsterGroupActivationManager.enabled = true;
                    }
                    lootDropManager.enabled = true;
                    break;
                case Scenes.MetaShop:
                    lootDropManager.enabled = false;
                    lootPurchaseManager.enabled = true;
                    if (monsterGroupActivationManager != null)
                    {
                        monsterGroupActivationManager.enabled = false;
                    }
                    break;
                case Scenes.PermaShop:
                    lootDropManager.enabled = false;
                    lootPurchaseManager.enabled = true;
                    if (monsterGroupActivationManager != null)
                    {
                        monsterGroupActivationManager.enabled = false;
                    }
                    break;
                default:
                    break;
            }
        }
    }
}

/***********************/
/** TitleScreen.cs **/
/***********************/

using NeonLadder.Core;
using NeonLadder.Events;
using NeonLadder.Mechanics.Enums;
using NeonLadderURP.DataManagement;
using TMPro;
using UnityEngine;
using UnityEngine.SceneManagement;

public class TitleScreen : MonoBehaviour
{
    public void Start()
    {
        if (SaveSystem.SaveExists())
        {
            GameObject.FindGameObjectWithTag(Tags.PlayButton.ToString()).GetComponentInChildren<TextMeshProUGUI>().text = "Resume Game";
        }
    }
    public void StartGame()
    {
        SceneManager.LoadScene(Scenes.Staging.ToString());
    }

    public void OnApplicationQuit()
    {
        Application.Quit();
    }
}

/***********************/
/** CollisionController.cs **/
/***********************/

using NeonLadder.Events;
using NeonLadder.Managers;
using NeonLadder.Mechanics.Enums;
using NeonLadder.Mechanics.Stats;
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using static NeonLadder.Core.Simulation;

namespace NeonLadder.Mechanics.Controllers
{
    public class CollisionController : MonoBehaviour
    {
        public Health health { get; private set; }
        private KinematicObject otherActor;
        private GameObject otherActorParent;
        
        private KinematicObject thisActor;
        private GameObject thisActorParent;

        // Auto-property with default value and validation logic
        [SerializeField]
        private float duplicateCollisionAvoidanceTimer = 0.6f;
        public virtual float DuplicateCollisionAvoidanceTimer
        {
            get => duplicateCollisionAvoidanceTimer;
            set => duplicateCollisionAvoidanceTimer = Mathf.Max(0.6f, value);
        }

        private HashSet<GameObject> recentCollisions = new HashSet<GameObject>();

        private void Awake()
        {
            //ugh
            DuplicateCollisionAvoidanceTimer = duplicateCollisionAvoidanceTimer;
     
            thisActorParent = GetComponentInParent<Rigidbody>().gameObject;
            health = thisActorParent.GetComponent<Health>();
            thisActor = thisActorParent.GetComponentInChildren<KinematicObject>();
        }

        private void OnEnable()
        {
            if (ManagerController.Instance == null)
            {
                Debug.Log("Managers prefab is missing, or it's instance is missing an implementaiton.");
            }
            else
            {
                ManagerController.Instance.eventManager.StartListening("OnTriggerEnter", thisActorParent, OnTriggerEnter);
            }
        }

        private void OnDisable()
        {
            //This stuff happens on Actor death.
            //if (ManagerController.Instance == null)
            //{
            //    Debug.Log("Managers prefab is missing, or it's instance is missing an implementaiton.");
            //}
            //else
            //{
            //    ManagerController.Instance.eventManager.StopListening("OnTriggerEnter", thisActorParent, OnTriggerEnter);
            //}
        }

        private void OnTriggerEnter(Collider other)
        {
            // If collider is type of terrain collider, schedule terrain collision event
            if (other is TerrainCollider && thisActor is Player)
            {
                Schedule<PlayerTerrainCollision>();
                return;
            }
            else if (other is TerrainCollider && thisActor is Enemy)
            {
                var coll = Schedule<EnemyTerrainCollision>();
                coll.enemy = thisActor as Enemy;

                return;
            }
            else if (thisActorParent.layer == LayerMask.NameToLayer(Layers.Dead.ToString()) || other.gameObject.layer == LayerMask.NameToLayer(Layers.Dead.ToString()))
            {
                return;
            }
            

            // If we got this far, we know it's probably a legit attack collision.
            try
            {
                otherActorParent = other.GetComponentInParent<Rigidbody>().gameObject;
                otherActor = otherActorParent.GetComponentInChildren<KinematicObject>();
            }
            catch (Exception ex)
            {
                if (other.gameObject.layer == LayerMask.NameToLayer(Layers.TransparentFX.ToString()) || other.tag == nameof(Tags.Untagged))
                {
                    //see Collectible class for this (for now, unsure if should move to here, or schedule event, etc), or something collided with an untagged object, likely a building.
                    return;
                }
                else
                {
                    Debug.LogError($"Error finding attacking actor: {ex.Message} \n {other.tag}");
                    return;
                }
            }

            if (otherActorParent.tag == nameof(Tags.PlayerProjectile) && thisActorParent.GetComponentInChildren<Player>() != null) //can't shoot myself.
            {
                return;
            }
            else if (thisActor is Enemy && otherActor is Enemy) //enemies can hurt each other.
            {
                return;
            }
            else
            {
                if (!recentCollisions.Contains(otherActorParent))
                {
                    recentCollisions.Add(otherActorParent);
                    StartCoroutine(RemoveFromRecentCollisions(otherActorParent));

                    if (other.gameObject.layer == LayerMask.NameToLayer(Layers.Battle.ToString()))
                    {
                        if (otherActorParent.tag == nameof(Tags.PlayerProjectile))
                        {
                            health.Decrement(otherActorParent.GetComponent<ProjectileController>().Damage);
                            Destroy(otherActorParent);
                        }
                        else if (otherActor.IsUsingMelee)
                        {
                            //if (otherActor is Player)
                            //{
                            //    Debug.Log($"Other actor is player");
                            //}

                            //if (otherActor is Enemy)
                            //{
                            //    Debug.Log($"Other actor is enemy");
                            //}

                            //Debug.Log($"{thisActor.transform.parent.gameObject.name} took {otherActor.GetComponent<MeleeController>().Damage} damage from {otherActorParent.name} @ {Time.time}");
                            health.Decrement(otherActor.GetComponent<MeleeController>().Damage);
                        }
                        else
                        {
                            Debug.Log("Something went wrong");
                        }
                    }
                }
            }
        }


        private IEnumerator RemoveFromRecentCollisions(GameObject obj)
        {
            if (DuplicateCollisionAvoidanceTimer > 0)
            {
                yield return new WaitForSeconds(DuplicateCollisionAvoidanceTimer);
            }
            recentCollisions.Remove(obj);
        }
    }
}

/***********************/
/** SceneChangeController.cs **/
/***********************/

using NeonLadder.Core;
using NeonLadder.Managers;
using NeonLadder.Mechanics.Controllers;
using NeonLadder.Mechanics.Enums;
using NeonLadder.Models;
using UnityEngine;
using UnityEngine.SceneManagement;

public class SceneChangeController : MonoBehaviour
{
    public string SceneName;
    private PlatformerModel model;
    private Player player;
    private PlayerCameraPositionManager playerAndCameraPositionManager;

    private void Awake()
    {
        model = Simulation.GetModel<PlatformerModel>();
        player = model.Player;
        playerAndCameraPositionManager = GameObject.FindGameObjectWithTag(Tags.Managers.ToString()).GetComponentInChildren<PlayerCameraPositionManager>();
        SceneManager.sceneLoaded += OnSceneLoaded;
    }

    private void OnDisable()
    {
        SceneManager.sceneLoaded -= OnSceneLoaded;
    }

    private void OnTriggerEnter(Collider collision)
    {
        if (collision.CompareTag(Tags.Player.ToString()))
        {
            model.VirtualCamera.enabled = false;
            SceneManager.LoadScene(SceneName); //breakpoint here
        }
    }

    private void OnSceneLoaded(Scene scene, LoadSceneMode mode)
    {
        if (player == null)
        {
            return;
        }

        player.DisableZMovement();

        Vector3 playerPosition;
        Vector3 cameraPosition;
        Quaternion cameraRotation;

        if (playerAndCameraPositionManager.TryGetState(scene.name, out playerPosition, out cameraPosition, out cameraRotation))
        {
            player.Teleport(playerPosition);
            GameObject.FindGameObjectWithTag(Tags.MainCamera.ToString()).transform.position = cameraPosition;
        }
        else
        {
            GameObject spawnPoint = GameObject.FindGameObjectWithTag(Tags.SpawnPoint.ToString());
            if (spawnPoint != null)
            {
                //Debug.Log($"Current Player position: {player.transform.position} -> SpawnPoint found in the scene: {spawnPoint.transform.position}");
                if (player.transform.parent.position != spawnPoint.transform.position)
                {
                    //Debug.Log("Teleporting player to SpawnPoint position.");
                    player.Teleport(spawnPoint.transform.position);
                    //player.Actions.transform.position = spawnPoint.transform.position;
                }
                //player.transform.position = spawnPoint.transform.position;
            }
            else
            {
                Debug.LogWarning("No SpawnPoint found in the scene.");
            }
        }
        model.VirtualCamera.enabled = true;
        player.transform.parent.rotation = Quaternion.Euler(0, 90, 0);
        if (player.transform.parent.position.y < 0)
        {
            player.transform.parent.position = new Vector3(player.transform.parent.position.x, 0.01f, player.transform.parent.position.z);
        }

        SceneManager.sceneLoaded -= OnSceneLoaded;
    }
}

/***********************/
/** PortalSpawnController.cs **/
/***********************/

using System.Collections.Generic;
using UnityEngine;

public class PortalSpawnController : MonoBehaviour
{
    public List<GameObject> Prefabs = new List<GameObject>();
    public float SpawnIntervalInSeconds = 5f;
    public float PortalLifetimeInSeconds = 0f;

    private float spawnTimer = 0f;
    private float lifetimeTimer = 0f;
    private bool isSpawning = true;

    // Start is called before the first frame update
    void Start()
    {
        spawnTimer = SpawnIntervalInSeconds;
        lifetimeTimer = PortalLifetimeInSeconds;
    }

    // Update is called once per frame
    void Update()
    {
        if (isSpawning)
        {
            spawnTimer -= Time.deltaTime;
            if (spawnTimer <= 0f)
            {
                SpawnRandomPrefabFromPortal();
                spawnTimer = SpawnIntervalInSeconds;
            }

            if (PortalLifetimeInSeconds > 0)
            {
                lifetimeTimer -= Time.deltaTime;
                if (lifetimeTimer <= 0f)
                {
                    DespawnPortal();
                }
            }
        }
    }

    private void SpawnRandomPrefabFromPortal()
    {
        if (Prefabs.Count > 0)
        {
            int index = Random.Range(0, Prefabs.Count);
            //Debug.Log($"Spawning prefab at index: {index}"); // Debug statement
            Instantiate(Prefabs[index], transform.position, transform.rotation);
        }
    }

    private void DespawnPortal()
    {
        isSpawning = false;
        Destroy(gameObject);
    }
}

/***********************/
/** BaseAction.cs **/
/***********************/

using NeonLadder.Common;
using TMPro;
using UnityEngine;
using UnityEngine.InputSystem;

namespace NeonLadder.Mechanics.Controllers
{
    public class BaseAction : MonoBehaviour
    {
        [SerializeField]
        public TextMeshProUGUI PlayerActionsDebugText;

        [SerializeField]
        public TextMeshProUGUI AnimationDebuggingText;

        [SerializeField]
        public TextMeshProUGUI InputDebuggingText;

        [SerializeField]
        public TextMeshProUGUI ControllerNameDebuggingText;

        [SerializeField]
        public TextMeshProUGUI TouchScreenSupportDebuggingText;

        private bool HasTouchScreen => Input.touchSupported;

        private bool showControllerDebugLastState = Constants.DisplayControllerDebugInfo;

        private InputDevice controller;

        protected virtual void ConfigureControls(Player player)
        {
            ControllerDebugging.PrintDebugControlConfiguration(player);
        }

        void OnDrawGizmos()
        {
            Constants.DisplayAnimationDebugInfo = true;
            Constants.DisplayPlayerActionDebugInfo = true;
            Constants.DisplayKeyPresses = true;
            Constants.DisplayControllerDebugInfo = true;
        }

        protected virtual void Awake()
        {
            // Initialize the controller field with the first connected controller device
            if (Gamepad.current != null)
            {
                controller = Gamepad.current;
            }
            else if (Keyboard.current != null)
            {
                controller = Keyboard.current;
            }
            else
            {
                Debug.LogWarning("No controller or keyboard found.");
            }
        }

        protected void OnDestroy() { }

        protected void OnDisable() { }

        protected virtual void Update()
        {
            if (showControllerDebugLastState != Constants.DisplayControllerDebugInfo)
            {
                showControllerDebugLastState = Constants.DisplayControllerDebugInfo;
            }

            if (TouchScreenSupportDebuggingText != null)
            {
                TouchScreenSupportDebuggingText.gameObject.SetActive(Constants.DisplayTouchScreenDebugInfo);
                if (Constants.DisplayTouchScreenDebugInfo)
                {
                    TouchScreenSupportDebuggingText.text = $"Touch Screen support: {HasTouchScreen}";
                }
            }

            if (ControllerNameDebuggingText != null)
            {
                ControllerNameDebuggingText.gameObject.SetActive(Constants.DisplayControllerDebugInfo);
                if (Constants.DisplayControllerDebugInfo)
                {
                    if (controller != null)
                    {
                        ControllerNameDebuggingText.text = $"Controller: {ControllerDebugging.GetDeviceDebugText(controller)}";
                    }
                    else
                    {
                        ControllerNameDebuggingText.text = "Controller: None";
                    }
                }
            }
        }
    }
}

/***********************/
/** KinematicObject.cs **/
/***********************/

using NeonLadder.Core;
using NeonLadder.Mechanics.Enums;
using NeonLadder.Models;
using System.Collections.Generic;
using UnityEngine;

namespace NeonLadder.Mechanics.Controllers
{
    public class KinematicObject : MonoBehaviour
    {
        public Player player { get; set; }
        public PlatformerModel model { get; private set; }
        public float minGroundNormalY = .75f;
        public float gravityModifier = 1f;
        public Vector3 velocity;
        public LayerMask layerMask;
        public bool IsGrounded { get; private set; }
        protected Vector3 targetVelocity;
        protected Vector3 groundNormal;
        //https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Scripting/Component.deprecated.cs
        protected new Rigidbody rigidbody;
        protected RaycastHit[] hitBuffer = new RaycastHit[16];
        protected const float minMoveDistance = 0.001f;
        protected const float shellRadius = 0.01f;

        [SerializeField]
        private bool isUsingMelee = true;
        public virtual bool IsUsingMelee
        {
            get => isUsingMelee;
            set => isUsingMelee = value;
        }
        public Animator animator { get; private set; }
        public virtual float deathAnimationDuration { get; set; }
        public virtual float attackAnimationDuration { get; set; }
        public virtual float victoryAnimationDuration { get; set; }
        public virtual float idleAnimationDuration { get; set; }

        public float DeathAnimationDuration => deathAnimationDuration;

        private Dictionary<Animations, float> animationClipLengths;

        public void Bounce(float value)
        {
            velocity.y = value;
        }

        public void Teleport(Vector3 position)
        {
            transform.parent.position = position;
            velocity = Vector3.zero;
        }

        private void CacheAnimationClipLengths()
        {
            animationClipLengths = new Dictionary<Animations, float>();
            AnimationClip[] clips = animator.runtimeAnimatorController.animationClips;

            foreach (var clip in clips)
            {
                if (System.Enum.TryParse(clip.name, out Animations animation))
                {
                    animationClipLengths[animation] = clip.length;
                }
            }
        }

        private float GetAnimationClipLength(Animations animation)
        {
            if (animationClipLengths.TryGetValue(animation, out float length))
            {
                return length;
            }
            Debug.LogWarning($"Animation {animation} not found on {animator.name}");
            return 0f;
        }

        protected virtual void OnEnable()
        {
            GuaranteeModelAndPlayer();
        }

        protected virtual void OnDisable()
        {
        }

        protected virtual void Start()
        {
            GuaranteeModelAndPlayer();
        }

        protected virtual void Awake()
        {
            rigidbody = GetComponentInParent<Rigidbody>();
            animator = GetComponentInParent<Animator>();
            switch (this)
            {
                case FlyingMinor:
                case Minor:
                case FlyingMajor:
                case Major:
                case Boss:
                case Enemy:
                    rigidbody.constraints = RigidbodyConstraints.FreezePositionZ;
                    break;
                case Player:
                    rigidbody.constraints = RigidbodyConstraints.FreezePositionZ;
                    break;
                default:
                    break;
            }

            //if (this.GetType() == typeof(Enemy))
            //{
            //    rigidbody.constraints = RigidbodyConstraints.FreezePositionZ;
            //}


            if (rigidbody != null)
            {
                rigidbody.isKinematic = true;
            }

            GuaranteeModelAndPlayer();
            CacheAnimationClipLengths();
            attackAnimationDuration = GetAnimationClipLength(Animations.Attack1);
            deathAnimationDuration = GetAnimationClipLength(Animations.Die);
            victoryAnimationDuration = GetAnimationClipLength(Animations.Victory);
            idleAnimationDuration = GetAnimationClipLength(Animations.Idle);
        }

        private void GuaranteeModelAndPlayer()
        {
            if (model == null)
            {
                model = Simulation.GetModel<PlatformerModel>();
            }
            if (player == null && model != null)
            {
                player = model.Player;
            }
        }

        protected virtual void Update()
        {
            targetVelocity = Vector3.zero;
            ComputeVelocity();
        }

        protected virtual void ComputeVelocity()
        {
            targetVelocity = Vector3.zero;
        }

        protected virtual void FixedUpdate()
        {
            IsGrounded = false;

            if (rigidbody.useGravity)
            {
                ApplyGravity();
            }

            UpdateVelocity();
            Vector3 deltaPosition = velocity * Time.deltaTime;
            Vector3 moveAlongGround = rigidbody.useGravity ? new Vector3(groundNormal.y, -groundNormal.x, 0) : Vector3.right;

            if (!rigidbody.constraints.HasFlag(RigidbodyConstraints.FreezePositionZ))
            {
                PerformMovement(new Vector3(0, 0, deltaPosition.z), false);
            }
            else
            {
                Vector3 horizontalMove = moveAlongGround * deltaPosition.x;
                PerformMovement(horizontalMove, false);
            }

            Vector3 verticalMove = Vector3.up * deltaPosition.y;
            PerformMovement(verticalMove, true);
        }

        void ApplyGravity()
        {
            velocity += gravityModifier * Physics.gravity * Time.deltaTime;
        }

        void UpdateVelocity()
        {
            velocity.x = targetVelocity.x;

            if (!rigidbody.constraints.HasFlag(RigidbodyConstraints.FreezePositionZ))
            {
                velocity.z = targetVelocity.z;
            }
            else
            {
                velocity.z = 0;
            }
        }

        void PerformMovement(Vector3 move, bool isVerticalMovement)
        {
            float distance = move.magnitude;
            if (distance > minMoveDistance)
            {
                Vector3 rayOrigin = transform.position;
                Vector3 rayDirection = move.normalized;

                int hitCount = Physics.RaycastNonAlloc(rayOrigin, rayDirection, hitBuffer, distance + shellRadius, layerMask);
                for (int i = 0; i < hitCount; i++)
                {
                    Vector3 currentNormal = hitBuffer[i].normal;
                    if (currentNormal.y > minGroundNormalY)
                    {
                        IsGrounded = true;
                        if (isVerticalMovement)
                        {
                            groundNormal = currentNormal;
                            currentNormal.x = 0;
                        }
                    }

                    if (IsGrounded)
                    {
                        AdjustVelocityForGroundCollision(currentNormal);
                    }
                    else if (rigidbody.useGravity)
                    {
                        AdjustVelocityForAirCollision();
                    }

                    float modifiedDistance = hitBuffer[i].distance - shellRadius;
                    distance = Mathf.Min(modifiedDistance, distance);
                }
            }

            rigidbody.position += move.normalized * distance;
        }


        void AdjustVelocityForGroundCollision(Vector3 normal)
        {
            float projection = Vector3.Dot(velocity, normal);
            if (projection < 0)
            {
                velocity -= projection * normal;
            }
        }

        void AdjustVelocityForAirCollision()
        {
            velocity.y = Mathf.Min(velocity.y, 0);
        }
    }
}

/***********************/
/** BaseStat.cs **/
/***********************/

//using DamageNumbersPro;
using NeonLadder.Mechanics.Controllers;
using UnityEngine;

namespace NeonLadder.Mechanics.Stats
{
    public abstract class BaseStat : MonoBehaviour
    {
        [SerializeField]
        public float current;
        public float max = 100;
        public bool IsDepleted => current == 0;
        protected DamageNumberController damageNumberController;

        public void Increment(float amount = 1)
        {
            current = Mathf.Clamp(current + amount, 0, max);
        }

        public void Decrement(float amount = 1)
        {
            current = Mathf.Clamp(current - amount, 0, max);

            //use parent objects type to determine if damage or stamina

            switch (this)
            {
                case Health:
                    if (damageNumberController != null)
                    {
                        damageNumberController.SpawnPopup(amount);
                    }
                    break;
                case Stamina:
                    //damageNumber.Spawn(transform.position, amount.ToString());
                    break;
            }

            if (current == 0)
            {
                OnDepleted();
            }
        }

        public void Deplete()
        {
            current = 0;
        }

        protected virtual void OnDepleted()
        {
            
        }

        protected virtual void Awake()
        {
            RestoreToMax();
            damageNumberController = GetComponent<DamageNumberController>();
        }

        protected virtual void RestoreToMax()
        {
            current = max;
        }
    }
}

/***********************/
/** Simulation.cs **/
/***********************/

using System.Collections.Generic;
using UnityEngine;


namespace NeonLadder.Core
{
    /// <summary>
    /// The Simulation class implements the discrete event simulator pattern.
    /// Events are pooled, with a default capacity of 4 instances.
    /// </summary>
    public static partial class Simulation
    {

        static HeapQueue<Event> eventQueue = new HeapQueue<Event>();
        static Dictionary<System.Type, Stack<Event>> eventPools = new Dictionary<System.Type, Stack<Event>>();

        /// <summary>
        /// Create a new event of type T and return it, but do not schedule it.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <returns></returns>
        static public T New<T>() where T : Event, new()
        {
            Stack<Event> pool;
            if (!eventPools.TryGetValue(typeof(T), out pool))
            {
                pool = new Stack<Event>(4);
                pool.Push(new T());
                eventPools[typeof(T)] = pool;
            }
            if (pool.Count > 0)
                return (T)pool.Pop();
            else
                return new T();
        }

        /// <summary>
        /// Clear all pending events and reset the tick to 0.
        /// </summary>
        public static void Clear()
        {
            eventQueue.Clear();
        }

        /// <summary>
        /// Schedule an event for a future tick, and return it.
        /// </summary>
        /// <returns>The event.</returns>
        /// <param name="tick">Tick.</param>
        /// <typeparam name="T">The event type parameter.</typeparam>
        static public T Schedule<T>(float tick = 0) where T : Event, new()
        {
            var ev = New<T>();
            ev.tick = Time.time + tick;
            eventQueue.Push(ev);
            return ev;
        }

        /// <summary>
        /// Reschedule an existing event for a future tick, and return it.
        /// </summary>
        /// <returns>The event.</returns>
        /// <param name="tick">Tick.</param>
        /// <typeparam name="T">The event type parameter.</typeparam>
        static public T Reschedule<T>(T ev, float tick) where T : Event, new()
        {
            ev.tick = Time.time + tick;
            eventQueue.Push(ev);
            return ev;
        }

        /// <summary>
        /// Return the simulation model instance for a class.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        static public T GetModel<T>() where T : class, new()
        {
            return InstanceRegister<T>.instance;
        }

        /// <summary>
        /// Set a simulation model instance for a class.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        static public void SetModel<T>(T instance) where T : class, new()
        {
            InstanceRegister<T>.instance = instance;
        }

        /// <summary>
        /// Destroy the simulation model instance for a class.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        static public void DestroyModel<T>() where T : class, new()
        {
            InstanceRegister<T>.instance = null;
        }

        /// <summary>
        /// Tick the simulation. Returns the count of remaining events.
        /// If remaining events is zero, the simulation is finished unless events are
        /// injected from an external system via a Schedule() call.
        /// </summary>
        /// <returns></returns>
        static public int Tick()
        {
            var time = Time.time;
            var executedEventCount = 0;
            while (eventQueue.Count > 0 && eventQueue.Peek().tick <= time)
            {
                var ev = eventQueue.Pop();
                var tick = ev.tick;
                ev.ExecuteEvent();
                if (ev.tick > tick)
                {
                    //event was rescheduled, so do not return it to the pool.
                }
                else
                {
                    // Debug.Log($"<color=green>{ev.tick} {ev.GetType().Name}</color>");
                    ev.Cleanup();
                    try
                    {
                        eventPools[ev.GetType()].Push(ev);
                    }
                    catch (KeyNotFoundException)
                    {
                        //This really should never happen inside a production build.
                        Debug.LogError($"No Pool for: {ev.GetType()}");
                    }
                }
                executedEventCount++;
            }
            return eventQueue.Count;
        }
    }
}



/***********************/
/** Simulation.Event.cs **/
/***********************/

//when I get my REST API setup.
//using NeonLadder.WebRequests;

namespace NeonLadder.Core
{
    public static partial class Simulation
    {
        /// <summary>
        /// An event is something that happens at a point in time in a simulation.
        /// The Precondition method is used to check if the event should be executed,
        /// as conditions may have changed in the simulation since the event was 
        /// originally scheduled.
        /// </summary>
        /// <typeparam name="Event"></typeparam>
        public abstract class Event : System.IComparable<Event>
        {
            internal float tick;

            public int CompareTo(Event other)
            {
                return tick.CompareTo(other.tick);
            }

            public abstract void Execute();

            public virtual bool Precondition() => true;

            internal virtual void ExecuteEvent()
            {
                if (Precondition())
                    Execute();

                //when I get my REST API setup.
                //WebRequestHandler.SendEventDataAsync(this.GetType().Name, tick);
            }

            /// <summary>
            /// This method is generally used to set references to null when required.
            /// It is automatically called by the Simulation when an event has completed.
            /// </summary>
            internal virtual void Cleanup()
            {

            }
        }

        /// <summary>
        /// Event<T> adds the ability to hook into the OnExecute callback
        /// whenever the event is executed. Use this class to allow functionality
        /// to be plugged into your application with minimal or zero configuration.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        public abstract class Event<T> : Event where T : Event<T>
        {
            public static System.Action<T> OnExecute;

            internal override void ExecuteEvent()
            {
                if (Precondition())
                {
                    Execute();
                    OnExecute?.Invoke((T)this);
                }
            }
        }
    }
}

/***********************/
/** PlayerAction.cs **/
/***********************/

using NeonLadder.Common;
using NeonLadder.Managers;
using NeonLadder.Mechanics.Enums;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.InputSystem;
using UnityEngine.SceneManagement;

namespace NeonLadder.Mechanics.Controllers
{
    public class PlayerAction : BaseAction
    {
        private PlayerCameraPositionManager playerPositionManager;
        private Player player;
        public Vector2 playerInput = new Vector2(0, 0);
        private float sprintTimeAccumulator = 0f;
        public bool isClimbing { get; set; }

        #region Jumping
        public bool isJumping { get; set; }
        public float jumpForce = 7f;
        private int jumpCount = 0;
        public int JumpCount => jumpCount;
        private int maxJumps = 1;
        public int MaxJumps => maxJumps;
        #endregion

        public InputActionMap playerActionMap;
        public InputActionMap uiActionMap;

        #region Sprinting  
        [SerializeField]
        public float sprintSpeed = Constants.DefaultMaxSpeed * Constants.SprintSpeedMultiplier;
        [SerializeField]
        public float sprintDuration = Constants.SprintDuration; // seconds
        [SerializeField]
        public ActionStates sprintState = ActionStates.Ready;
        public bool? IsSprinting => sprintState == ActionStates.Acting;
        [SerializeField]
        public bool stopSprint;
        #endregion

        #region Attacking
        [SerializeField]
        private float attackAnimationDuration;
        public float AttackAnimationDuration;

        private int meleeAttackAnimation = 23;
        private int rangedAttackAnimation = 75;

        [SerializeField]
        public ActionStates attackState = ActionStates.Ready;

        [SerializeField]
        public bool stopAttack;
        #endregion

        public List<GameObject> meleeWeaponGroups;
        public List<GameObject> rangedWeaponGroups;



        protected void Start()
        {
            player = GetComponent<Player>();
            var managerObj = GameObject.FindGameObjectWithTag(Tags.Managers.ToString());
            if (managerObj == null)
            {
                Debug.Log("Managers prefab not found in the scene.");
            }
            else
            {
                playerPositionManager = managerObj.GetComponentInChildren<PlayerCameraPositionManager>();
                ConfigureControls(player);
                ControllerDebugging.PrintDebugControlConfiguration(player);
                if (meleeWeaponGroups == null || meleeWeaponGroups.Count == 0)
                {
                    meleeWeaponGroups = new List<GameObject>(GameObject.FindGameObjectsWithTag("MeleeWeapons"));
                }
                if (rangedWeaponGroups == null || rangedWeaponGroups.Count == 0)
                {
                    rangedWeaponGroups = new List<GameObject>(GameObject.FindGameObjectsWithTag("Firearms"));
                }
            }
        }

        protected override void Update()
        {
            if (playerActionMap.enabled)
            {
                UpdateSprintState(ref player.velocity);

                UpdateAttackState();
            }

            if (AnimationDebuggingText != null)
            {
                AnimationDebuggingText.gameObject.SetActive(Constants.DisplayAnimationDebugInfo);
                if (Constants.DisplayAnimationDebugInfo)
                {
                    AnimationDebuggingText.text = AnimationDebugging.GetAnimationParameters(player.animator);
                }
            }

            if (PlayerActionsDebugText != null)
            {
                PlayerActionsDebugText.gameObject.SetActive(Constants.DisplayPlayerActionDebugInfo);
                if (Constants.DisplayPlayerActionDebugInfo)
                {
                    PlayerActionsDebugText.text = PlayerActionDebugging.GetPlayerActionParameters(player, this);
                }
            }

            base.Update();
        }

        protected new void OnDestroy()
        {
            UnsubscribeFromInputActions();
            base.OnDestroy();
        }

        protected new void OnDisable()
        {
            UnsubscribeFromInputActions();
            base.OnDisable();
        }

        protected void OnEnable()
        {
            var managerObj = GameObject.FindGameObjectWithTag(Tags.Managers.ToString());
            if (managerObj == null)
            {
                Debug.Log("Managers prefab not found in the scene.");
            }
            else
            {
                playerPositionManager = GameObject.FindGameObjectWithTag(Tags.Managers.ToString()).GetComponentInChildren<PlayerCameraPositionManager>();
                if (playerPositionManager == null)
                {
                    Debug.Log("PlayerPositionManager not found in the scene.");
                }

                if (playerActionMap == null)
                {
                    ConfigureControls(player);
                }
            }
        }

        private void UnsubscribeFromInputActions()
        {
            if (playerActionMap != null)
            {
                var sprintAction = playerActionMap.FindAction("Sprint");
                if (sprintAction != null)
                {
                    sprintAction.performed -= OnSprintPerformed;
                    sprintAction.canceled -= OnSprintCanceled;
                }

                var moveAction = playerActionMap.FindAction("Move");
                if (moveAction != null)
                {
                    moveAction.performed -= OnMovePerformed;
                    moveAction.canceled -= OnMoveCanceled;
                }

                var attack = playerActionMap.FindAction("Attack");
                if (attack != null)
                {
                    attack.performed -= OnAttackPerformed;
                    attack.canceled -= OnAttackCanceled;
                }

                var weaponSwapAction = playerActionMap.FindAction("WeaponSwap");
                if (weaponSwapAction != null)
                {
                    weaponSwapAction.performed -= OnWeaponSwap;
                }

                var jumpAction = playerActionMap.FindAction("Jump");
                if (jumpAction != null)
                {
                    jumpAction.performed -= OnJumpPerformed;
                }

                var upAction = playerActionMap.FindAction("Up");
                if (upAction != null)
                {
                    upAction.performed -= OnUpPerformed;
                }
            }
        }

        protected override void ConfigureControls(Player player)
        {
            playerActionMap = player.Controls.FindActionMap("Player");
            playerActionMap.Enable();

            var sprintAction = playerActionMap.FindAction("Sprint");
            sprintAction.performed += OnSprintPerformed;
            sprintAction.canceled += OnSprintCanceled;

            var moveAction = playerActionMap.FindAction("Move");
            moveAction.performed += OnMovePerformed;
            moveAction.canceled += OnMoveCanceled;

            var attack = playerActionMap.FindAction("Attack");
            attack.performed += OnAttackPerformed;
            attack.canceled += OnAttackCanceled;

            var weaponSwapAction = playerActionMap.FindAction("WeaponSwap");
            weaponSwapAction.performed += OnWeaponSwap;

            var jumpAction = playerActionMap.FindAction("Jump");
            jumpAction.performed += OnJumpPerformed;

            var upAction = playerActionMap.FindAction("Up");
            upAction.performed += OnUpPerformed;

            ControllerDebugging.PrintDebugControlConfiguration(player);
        }

        private bool isInZMovementZone = false;

        private void OnUpPerformed(InputAction.CallbackContext context)
        {
            if (isInZMovementZone)
            {
                var sceneName = SceneManager.GetActiveScene().name;
                var cameraPosition = GameObject.FindGameObjectWithTag(Tags.MainCamera.ToString()).transform.position;
                var cvcRotation = Game.Instance.model.VirtualCamera.gameObject.transform.rotation;

                playerPositionManager.SaveState(sceneName,
                                                player.transform.parent.position,
                                                cameraPosition,
                                                cvcRotation);

                player.EnableZMovement();
            }
        }

        public void SetZMovementZone(bool inZone)
        {
            isInZMovementZone = inZone;
        }

        private void OnJumpPerformed(InputAction.CallbackContext context)
        {
            if (player.IsGrounded || jumpCount < maxJumps)
            {
                isJumping = true;
            }
        }

        private void OnWeaponSwap(InputAction.CallbackContext context)
        {
            if (player.IsUsingMelee)
            {
                SwapWeapons(meleeWeaponGroups, rangedWeaponGroups);
            }
            else
            {
                SwapWeapons(rangedWeaponGroups, meleeWeaponGroups);
            }

            player.IsUsingMelee = !player.IsUsingMelee;
        }

        private void SwapWeapons(List<GameObject> currentWeapons, List<GameObject> newWeapons)
        {
            foreach (GameObject weaponGroup in currentWeapons)
            {
                var weapon = weaponGroup.transform.GetChild(0).gameObject;
                weapon.SetActive(false);
            }

            foreach (GameObject weaponGroup in newWeapons)
            {
                var weapon = weaponGroup.transform.GetChild(0).gameObject;
                weapon.SetActive(true);
            }
        }

        private void OnAttackPerformed(InputAction.CallbackContext context)
        {
            if (!player.Stamina.IsExhausted)
            {
                if (attackState == ActionStates.Ready)
                {
                    attackState = ActionStates.Preparing;
                    stopAttack = false;
                }
            }
        }

        public void OnAttackCanceled(InputAction.CallbackContext context)
        {
            if (attackState == ActionStates.Acting)
            {
                stopAttack = true;
            }
        }

        public void UpdateSprintState(ref Vector3 velocity)
        {
            float staminaCostPerTenthSecond = Constants.SprintStaminaCost * 0.1f;
            switch (sprintState)
            {
                case ActionStates.Preparing:
                    sprintDuration = Constants.SprintDuration; // Reset the sprint duration
                    sprintState = ActionStates.Acting;
                    stopSprint = false;
                    sprintTimeAccumulator = 0f; // Reset the time accumulator
                    break;

                case ActionStates.Acting:
                    if (stopSprint || sprintDuration <= 0)
                    {
                        sprintState = ActionStates.Acted;
                    }
                    else
                    {
                        sprintTimeAccumulator += Time.deltaTime;
                        if (sprintTimeAccumulator >= 0.1f)
                        {
                            player.Stamina.Decrement(staminaCostPerTenthSecond); // Decrement stamina
                            sprintTimeAccumulator -= 0.1f; // Subtract 0.1 seconds from the accumulator
                        }

                        sprintDuration -= Time.deltaTime;
                    }
                    break;

                case ActionStates.Acted:
                    sprintState = ActionStates.Ready;
                    stopSprint = false;
                    break;
            }
        }

        public void UpdateAttackState()
        {
            switch (attackState)
            {
                case ActionStates.Preparing:
                    attackState = ActionStates.Acting;
                    break;
                case ActionStates.Acting:
                    StartCoroutine(TryAttackEnemy());
                    attackState = ActionStates.Ready;
                    break;
                case ActionStates.Acted:
                    break;
            }
        }

        private void OnSprintPerformed(InputAction.CallbackContext context)
        {
            if (!player.Stamina.IsExhausted)
            {
                if (sprintState == ActionStates.Ready)
                {
                    sprintState = ActionStates.Preparing;
                    stopSprint = false;
                }
            }
        }

        private void OnSprintCanceled(InputAction.CallbackContext context)
        {
            if (IsSprinting ?? false)
            {
                stopSprint = true;
            }
        }

        private void OnMovePerformed(InputAction.CallbackContext context)
        {
            if (player.Health.IsAlive)
            {
                playerInput = context.ReadValue<Vector2>();
                if (playerInput.x != 0)
                {
                    float yRotation = playerInput.x > 0 ? 90 : -90;
                    transform.parent.localRotation = Quaternion.Euler(0, yRotation, 0);
                }
            }
        }

        private void OnMoveCanceled(InputAction.CallbackContext context)
        {
            playerInput = Vector2.zero; // No movement input
        }

        [SerializeField]
        private float percentageOfAnimationToIgnore = 0.35f; // Adjust this value to experiment with different timings

        private IEnumerator TryAttackEnemy()
        {
            var attackComponents = transform.parent.gameObject.GetComponentsInChildren<Collider>()
                                                           .Where(c => c.gameObject != transform.parent.gameObject).ToList();
            if (attackComponents != null && attackComponents.Count > 0)
            {
                player.animator.SetLayerWeight(Constants.PlayerActionLayerIndex, 1); // Activate action layer

                // Start the attack animation
                player.animator.SetInteger(nameof(PlayerAnimationLayers.action_animation), (player.IsUsingMelee) ? meleeAttackAnimation : rangedAttackAnimation);

                // Calculate the duration to ignore based on the percentage
                float ignoreDuration = player.attackAnimationDuration * percentageOfAnimationToIgnore;

                // Wait for the ignore duration
                yield return new WaitForSeconds(ignoreDuration);

                // Change the attack components to the battle layer
                foreach (var attackComponent in attackComponents)
                {
                    attackComponent.gameObject.layer = LayerMask.NameToLayer(nameof(Layers.Battle));
                }

                // Wait for the remaining duration of the attack animation
                yield return new WaitForSeconds(player.attackAnimationDuration - ignoreDuration);

                // Reset the attack components back to the default layer
                foreach (var attackComponent in attackComponents)
                {
                    attackComponent.gameObject.layer = LayerMask.NameToLayer(nameof(Layers.Default));
                }

                // Reset the action layer weight and animation state
                player.animator.SetInteger(nameof(PlayerAnimationLayers.action_animation), 0);
                player.animator.SetLayerWeight(Constants.PlayerActionLayerIndex, 0); // Deactivate action layer
            }
        }


        public void IncrementAvailableMidAirJumps()
        {
            maxJumps++;
        }

        public void IncrementJumpCount()
        {
            jumpCount++;
        }

        public void ResetJumpCount()
        {
            jumpCount = 0;
        }
    }
}

/***********************/
/** BaseGameEvent.cs **/
/***********************/

using NeonLadder.Core;
using NeonLadder.Mechanics.Controllers;
using NeonLadder.Models;

namespace NeonLadder.Events
{
    public abstract class BaseGameEvent<T> : Simulation.Event<T> where T : Simulation.Event<T>, new()
    {
        protected PlatformerModel model => Game.Instance.model;
    }
}

/***********************/
/** EventManager.cs **/
/***********************/

using System;
using System.Collections.Generic;
using UnityEngine;

namespace NeonLadder.Managers
{
    public class EventManager : MonoBehaviour
    {
        private Dictionary<string, Dictionary<GameObject, Action<Collider>>> eventDictionary;

        void Awake()
        {
            if (eventDictionary == null)
            {
                eventDictionary = new Dictionary<string, Dictionary<GameObject, Action<Collider>>>();
            }
        }

        public void StartListening(string eventName, GameObject listener, Action<Collider> callback)
        {
            if (!eventDictionary.TryGetValue(eventName, out var listeners))
            {
                listeners = new Dictionary<GameObject, Action<Collider>>();
                eventDictionary[eventName] = listeners;
            }

            if (listeners.ContainsKey(listener))
            {
                listeners[listener] += callback;
            }
            else
            {
                listeners.Add(listener, callback);
            }
        }

        public void StopListening(string eventName, GameObject listener, Action<Collider> callback)
        {
            if (eventDictionary.TryGetValue(eventName, out var listeners))
            {
                if (listeners.ContainsKey(listener))
                {
                    listeners[listener] -= callback;
                    if (listeners[listener] == null)
                    {
                        listeners.Remove(listener);
                    }
                }
            }
        }

        public void TriggerEvent(string eventName, GameObject listener, Collider collider)
        {
            if (eventDictionary.TryGetValue(eventName, out var listeners))
            {
                if (listeners.TryGetValue(listener, out var thisEvent))
                {
                    thisEvent.Invoke(collider);
                }
            }
        }
    }
}
